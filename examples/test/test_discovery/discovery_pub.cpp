
/*!
 * @file LoanableHelloWorldPublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include "include/discovery_pub.h"

#include "fastdds/dds/publisher/Publisher.hpp"
#include "fastdds/dds/publisher/qos/PublisherQos.hpp"
#include "fastdds/dds/publisher/DataWriter.hpp"
#include "fastdds/dds/publisher/qos/DataWriterQos.hpp"
#include "fastdds/rtps/attributes/RTPSParticipantAttributes.h"

#include <thread>
#include <chrono>

using namespace eprosima::fastdds::dds;
using namespace eprosima::fastrtps::rtps;

bool ZombiePub::init() {
  /* Initialize data_ here */


  // Get default participant QoS
  DomainParticipantQos server_qos = PARTICIPANT_QOS_DEFAULT;

  // Set participant as SERVER
  server_qos.wire_protocol().builtin.discovery_config.discoveryProtocol =
      DiscoveryProtocol_t::SERVER;

  // Set SERVER's GUID prefix
  std::istringstream("44.53.00.5f.45.50.52.4f.53.49.4d.41") >> server_qos.wire_protocol().prefix;

  // Set SERVER's listening locator for PDP
  eprosima::fastrtps::rtps::Locator_t locator;
  IPLocator::setIPv4(locator, 127, 0, 0, 1);
  locator.port = 11811;
  server_qos.wire_protocol().builtin.metatrafficUnicastLocatorList.push_back(locator);

  /* Add a remote serve to which this server will connect */
  // Set remote SERVER's GUID prefix
  RemoteServerAttributes remote_server_att;
  remote_server_att.ReadguidPrefix("44.53.01.5f.45.50.52.4f.53.49.4d.41");

  // Set remote SERVER's listening locator for PDP
  Locator_t remote_locator;
  IPLocator::setIPv4(remote_locator, 127, 0, 0, 1);
  remote_locator.port = 11812;
  remote_server_att.metatrafficUnicastLocatorList.push_back(remote_locator);

  // Add remote SERVER to SERVER's list of SERVERs
  server_qos.wire_protocol().builtin.discovery_config.m_DiscoveryServers.push_back(remote_server_att);

  // Create SERVER
  participant_ = DomainParticipantFactory::get_instance()->create_participant(0, server_qos);




  if (participant_ == nullptr) {
    return false;
  }

  //REGISTER THE TYPE
  type_.register_type(participant_);

  //CREATE THE PUBLISHER
  publisher_ = participant_->create_publisher(PUBLISHER_QOS_DEFAULT, nullptr);
  if (publisher_ == nullptr) {
    return false;
  }


  //CREATE THE TOPIC
  topic_ = participant_->create_topic(
      "LoanableHelloWorldTopic",
      type_.get_type_name(),
      TOPIC_QOS_DEFAULT);
  if (topic_ == nullptr) {
    return false;
  }

  // CREATE THE WRITER
  DataWriterQos wqos = publisher_->get_default_datawriter_qos();
  wqos.history().depth = 1;
  wqos.durability().kind = TRANSIENT_LOCAL_DURABILITY_QOS;
  wqos.data_sharing().automatic();
  writer_ = publisher_->create_datawriter(topic_, wqos, &listener_);
  if (writer_ == nullptr) {
    return false;
  }

  std::cout << "LoanableHelloWorld DataWriter created." << std::endl;
  return true;
}

void ZombiePub::PubListener::on_publication_matched(
    eprosima::fastdds::dds::DataWriter*,
    const eprosima::fastdds::dds::PublicationMatchedStatus& info) {
  if (info.current_count_change == 1) {
    matched = info.total_count;
    std::cout << "DataWriter matched." << std::endl;
  } else if (info.current_count_change == -1) {
    matched = info.total_count;
    std::cout << "DataWriter unmatched." << std::endl;
  } else {
    std::cout << info.current_count_change
              << " is not a valid value for PublicationMatchedStatus current count change" << std::endl;
  }
}

void ZombiePub::run() {
  std::cout << "LoanableHelloWorld DataWriter waiting for DataReaders." << std::endl;
  int msgsent = 0;

  while (1) {
    std::this_thread::sleep_for(std::chrono::milliseconds(250)); // Sleep 250 ms

    void* sample = nullptr;
    if (ReturnCode_t::RETCODE_OK == writer_->loan_sample(sample)) {
      std::cout << "Preparing sample at address " << sample << std::endl;
      auto* data = static_cast<HW*>(sample);
      data->index() = msgsent + 1;
      memcpy(data->message().data(), "LoanableHelloWorld ", 20);
      writer_->write(sample);
    }
    ++msgsent;
    std::cout << "Sending sample, count=" << msgsent;

  }
}

int main() {
  ZombiePub loanable_hello_world_publisher;
  loanable_hello_world_publisher.init();
  loanable_hello_world_publisher.run();
}