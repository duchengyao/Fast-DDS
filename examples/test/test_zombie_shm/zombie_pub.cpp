
/*!
 * @file LoanableHelloWorldPublisher.cpp
 * This file contains the implementation of the publisher functions.
 *
 * This file was generated by the tool fastcdrgen.
 */


#include "include/zombie_pub.h"

#include "fastdds/dds/publisher/Publisher.hpp"
#include "fastdds/dds/publisher/qos/PublisherQos.hpp"
#include "fastdds/dds/publisher/DataWriter.hpp"
#include "fastdds/dds/publisher/qos/DataWriterQos.hpp"

#include <thread>
#include <chrono>

using namespace eprosima::fastdds::dds;



bool ZombiePub::init() {
  /* Initialize data_ here */

  //CREATE THE PARTICIPANT
  DomainParticipantQos pqos;
  pqos.name("Participant_pub");
  participant_ = DomainParticipantFactory::get_instance()->create_participant(0, pqos);
  if (participant_ == nullptr) {
    return false;
  }

  //REGISTER THE TYPE
  type_.register_type(participant_);

  //CREATE THE PUBLISHER
  publisher_ = participant_->create_publisher(PUBLISHER_QOS_DEFAULT, nullptr);
  if (publisher_ == nullptr) {
    return false;
  }

  //CREATE THE TOPIC
  topic_ = participant_->create_topic(
      "LoanableHelloWorldTopic",
      type_.get_type_name(),
      TOPIC_QOS_DEFAULT);
  if (topic_ == nullptr) {
    return false;
  }

  // CREATE THE WRITER
  DataWriterQos wqos = publisher_->get_default_datawriter_qos();
  wqos.history().depth = 1;
  wqos.durability().kind = TRANSIENT_LOCAL_DURABILITY_QOS;
  wqos.data_sharing().automatic();
  writer_ = publisher_->create_datawriter(topic_, wqos, &listener_);
  if (writer_ == nullptr) {
    return false;
  }

  std::cout << "LoanableHelloWorld DataWriter created." << std::endl;
  return true;
}

void ZombiePub::PubListener::on_publication_matched(
    eprosima::fastdds::dds::DataWriter*,
    const eprosima::fastdds::dds::PublicationMatchedStatus& info) {
  if (info.current_count_change == 1) {
    matched = info.total_count;
    std::cout << "DataWriter matched." << std::endl;
  } else if (info.current_count_change == -1) {
    matched = info.total_count;
    std::cout << "DataWriter unmatched." << std::endl;
  } else {
    std::cout << info.current_count_change
              << " is not a valid value for PublicationMatchedStatus current count change" << std::endl;
  }
}

void ZombiePub::run() {
  std::cout << "LoanableHelloWorld DataWriter waiting for DataReaders." << std::endl;
  int msgsent = 0;

  while (1) {
    std::this_thread::sleep_for(std::chrono::milliseconds(250)); // Sleep 250 ms

    void* sample = nullptr;
    if (ReturnCode_t::RETCODE_OK == writer_->loan_sample(sample)) {
      std::cout << "Preparing sample at address " << sample << std::endl;
      auto* data = static_cast<HW*>(sample);
      data->index() = msgsent + 1;
      memcpy(data->message().data(), "LoanableHelloWorld ", 20);
      writer_->write(sample);
    }
    ++msgsent;
    std::cout << "Sending sample, count=" << msgsent;

  }
}

int main() {
  ZombiePub loanable_hello_world_publisher;
  loanable_hello_world_publisher.init();
  loanable_hello_world_publisher.run();
}